C51 COMPILER V9.57.0.0   DISPLAY                                                           03/25/2018 22:06:55 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE DISPLAY
OBJECT MODULE PLACED IN .\Objects\display.obj
COMPILER INVOKED BY: D:\Program Files\Keil_v5\C51\BIN\C51.EXE USER\display.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Include) 
                    -DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\Listings\display.lst) OBJECT(.\Objects\display.obj)

line level    source

   1          
   2          #include "N76E003.h"
   3          #include "SFR_Macro.h"
   4          #include "Function_define.h"
   5          #include "Common.h"
   6          #include "Delay.h"
   7          
   8          #include "display.h"
   9          
  10          sbit HC595_SER = P0^0;
  11          sbit HC595_SCLK = P1^0;
  12          sbit HC595_RCLK = P1^1;
  13          sbit HC595_SCLR = P1^2;
  14          sbit ICN2012_A0 = P0^5;
  15          sbit ICN2012_A1 = P0^6;
  16          sbit ICN2012_A2 = P0^7;
  17          sbit ICN2012_E1 = P1^5;
  18          sbit BEEPER = P0^3;
  19          
  20          uint8_t timeCnt = 0;
  21          uint8_t workState;
  22          uint16_t secSet;
  23          extern uint16_t secCnt;
  24          extern uint8_t workMode;
  25          extern uint8_t keyLevel;
  26          extern uint8_t lightLevel;
  27          
  28          extern xdata int Temperature;
  29          extern xdata uint8_t RelativeHumidity;
  30          extern xdata uint8_t time[8];
  31          
  32          bit timerON = 0;
  33          bit time_sFlag = 1;
  34          bit T_RH_delayFlag = 1;
  35          
  36          void display_Init()
  37          {
  38   1              HC595_SCLR = 1;
  39   1              ICN2012_A0 = 0;
  40   1              ICN2012_A1 = 0;
  41   1              ICN2012_A2 = 0;
  42   1              ICN2012_E1 = 0;
  43   1              BEEPER = 0;     
  44   1              
  45   1              TIMER1_MODE2_ENABLE;
  46   1              TH1 = 56;
  47   1          TL1 = 56;  
  48   1              set_ET1;                                    //enable Timer1 interrupt
  49   1              set_EA;
  50   1              set_TR1;
  51   1      }
  52          
  53          
  54          unsigned char code nAsciiDot[] =              // ASCII
C51 COMPILER V9.57.0.0   DISPLAY                                                           03/25/2018 22:06:55 PAGE 2   

  55          {
  56                  0x00,0x70,0x88,0x98,0xA8,0xC8,0x88,0x70, // -0-
  57                  0x00,0x20,0x60,0x20,0x20,0x20,0x20,0x70, // -1-
  58                  0x00,0x70,0x88,0x08,0x30,0x40,0x80,0xF8, // -2-
  59                  0x00,0xF8,0x08,0x10,0x30,0x08,0x88,0x70, // -3-
  60                  0x00,0x10,0x30,0x50,0x90,0xF8,0x10,0x10, // -4-
  61                  0x00,0xF8,0x80,0xF0,0x08,0x08,0x88,0x70, // -5-
  62                  0x00,0x38,0x40,0x80,0xF0,0x88,0x88,0x70, // -6-
  63                  0x00,0xF8,0x08,0x10,0x20,0x40,0x40,0x40, // -7-
  64                  0x00,0x70,0x88,0x88,0x70,0x88,0x88,0x70, // -8-
  65                  0x00,0x70,0x88,0x88,0x78,0x08,0x10,0xE0, // -9-
  66                  0x00,0x00,0x40,0x40,0x00,0x40,0x40,0x00, // -:-
  67                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // - -
  68                  0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00, // ---
  69                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80, // -.-
  70                  0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x00, // -`-
  71                  0x00,0xC0,0xC8,0x10,0x20,0x40,0x98,0x18, // -%-
  72                  0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80, // -.-
  73                  0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80, // -.-
  74                  0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80, // -.-
  75          };
  76          
  77          static void delay(uint8_t cnt)
  78          {
  79   1              uint8_t i;
  80   1              for(i=0;i<cnt;i++)
  81   1              {
  82   2                      nop;nop;nop;nop;nop;nop;nop;
  83   2                      nop;nop;nop;nop;nop;nop;nop;
  84   2                      nop;nop;nop;nop;nop;nop;nop;
  85   2                      nop;nop;nop;nop;nop;nop;nop;
  86   2              }
  87   1      }
  88          
  89          /* 按秒表方式显示 0000 */
  90          uint32_t dataCombine_Timer1(uint16_t secCnt,uint8_t colLine)
  91          {
  92   1              uint16_t i,number;
  93   1              uint32_t result=0;
  94   1              number = (secCnt/1000)%10;
  95   1              i = number*8+colLine;
  96   1              result = (result|nAsciiDot[i])<<6;
  97   1              number = (secCnt/100)%10;
  98   1              i = number*8+colLine;
  99   1              result = (result|nAsciiDot[i])<<6;
 100   1              number = (secCnt/10)%10;
 101   1              i = number*8+colLine;
 102   1              result = (result|nAsciiDot[i])<<6;              
 103   1              result = (result|nAsciiDot[0x68+colLine])<<1;
 104   1              number = secCnt%10;
 105   1              i = number*8+colLine;
 106   1              result = (result|nAsciiDot[i])>>3;
 107   1              return result;
 108   1      }
 109          
 110          /* 按计时方式显示 00:00 */
 111          uint32_t dataCombine_Timer2(uint16_t secCnt,uint8_t colLine)
 112          {
 113   1              uint16_t i,number;
 114   1              uint32_t result=0;
 115   1              number = (secCnt/6000)%10;
 116   1              i = number*8+colLine;
C51 COMPILER V9.57.0.0   DISPLAY                                                           03/25/2018 22:06:55 PAGE 3   

 117   1              result = (result|nAsciiDot[i])<<5;
 118   1              number = (secCnt/600)%10;
 119   1              i = number*8+colLine;
 120   1              result = (result|nAsciiDot[i])<<5;
 121   1              result = (result|nAsciiDot[0x50+colLine])<<3;
 122   1              number = (secCnt%600)/100;
 123   1              i = number*8+colLine;
 124   1              result = (result|nAsciiDot[i])<<5;                      
 125   1              number = ((secCnt%600)/10)%10;
 126   1              i = number*8+colLine;
 127   1              result = (result|nAsciiDot[i])>>3;
 128   1              return result;
 129   1      }
 130          
 131          void display_TimerUpMode(uint8_t timerUpMode)
 132          {
 133   1              uint8_t i,j,level,mode;
 134   1              uint32_t rowData;
 135   1              
 136   1              if(timerON==0)
 137   1              {       
 138   2                      timerON = 1;
 139   2                      secCnt = 0;
 140   2              }
 141   1              Enable_ADC_AIN0;
 142   1              clr_ADCF;
 143   1              set_ADCS;                                                                       // ADC start trig signal
 144   1          while(ADCF == 0);
 145   1              level = ADCRH;
 146   1              if(level<0x10)
 147   1                      mode = 0x01;
 148   1              else if(level<0x50)
 149   1              {
 150   2                      timerON = 0;
 151   2                      workMode = TimeMode;
 152   2                      return;
 153   2              }
 154   1              else if(level<0x90)
 155   1                      mode = 0x02;
 156   1      
 157   1              if(secSet!=0)
 158   1              {
 159   2                      if(secCnt>=secSet)
 160   2                              BEEPER = 1;
 161   2                      if(secCnt>secSet+50)
 162   2                              BEEPER = 0;
 163   2              }
 164   1              
 165   1              switch(mode)
 166   1              {
 167   2                      case 0x01:
 168   2                              secSet += 10;
 169   2                              for(j=0;j<10;j++)
 170   2                              {
 171   3                                      for(i=0;i<8;i++)
 172   3                                      {
 173   4                                              if(timerUpMode==TimerUpMode1)
 174   4                                                      rowData = dataCombine_Timer1(secSet,i);
 175   4                                              else if(timerUpMode==TimerUpMode2)
 176   4                                                      rowData = dataCombine_Timer2(secSet,i);
 177   4                                              write_ROW(rowData);
 178   4                                              ICN2012_E1 = 1; 
C51 COMPILER V9.57.0.0   DISPLAY                                                           03/25/2018 22:06:55 PAGE 4   

 179   4                                              delay(lightLevel);
 180   4                                              ICN2012_E1 = 0; 
 181   4                                              delay(0xFF-lightLevel);         
 182   4                                              P0 += 0x20;     
 183   4                                      }
 184   3                              }
 185   2                              mode = 0x03;
 186   2                      break;
 187   2                      case 0x02:
 188   2                              if(secSet>00)
 189   2                                      secSet -= 10;
 190   2                              for(j=0;j<10;j++)
 191   2                              {
 192   3                                      for(i=0;i<8;i++)
 193   3                                      {
 194   4                                              if(timerUpMode==TimerUpMode1)
 195   4                                                      rowData = dataCombine_Timer1(secSet,i);
 196   4                                              else if(timerUpMode==TimerUpMode2)
 197   4                                                      rowData = dataCombine_Timer2(secSet,i);
 198   4                                              write_ROW(rowData);
 199   4                                              ICN2012_E1 = 1; 
 200   4                                              delay(lightLevel);
 201   4                                              ICN2012_E1 = 0; 
 202   4                                              delay(0xFF-lightLevel);         
 203   4                                              P0 += 0x20;     
 204   4                                      }
 205   3                              }
 206   2                              mode = 0x03;
 207   2                      break;
 208   2                      case 0x03:
 209   2                              for(j=0;j<150;j++)
 210   2                              {
 211   3                                      for(i=0;i<8;i++)
 212   3                                      {
 213   4                                              if(timerUpMode==TimerUpMode1)
 214   4                                                      rowData = dataCombine_Timer1(secSet,i);
 215   4                                              else if(timerUpMode==TimerUpMode2)
 216   4                                                      rowData = dataCombine_Timer2(secSet,i);
 217   4                                              write_ROW(rowData);
 218   4                                              ICN2012_E1 = 1; 
 219   4                                              delay(lightLevel);
 220   4                                              ICN2012_E1 = 0; 
 221   4                                              delay(0xFF-lightLevel);         
 222   4                                              P0 += 0x20;     
 223   4                                      }
 224   3                              }
 225   2                              timerON = 0;
 226   2                              mode = 0x05;
 227   2                      break;
 228   2                      default:
 229   2                              for(i=0;i<8;i++)
 230   2                              {
 231   3                                      if(timerUpMode==TimerUpMode1)
 232   3                                              rowData = dataCombine_Timer1(secCnt,i);
 233   3                                      else if(timerUpMode==TimerUpMode2)
 234   3                                              rowData = dataCombine_Timer2(secCnt,i);
 235   3                                      write_ROW(rowData);
 236   3                                      ICN2012_E1 = 1; 
 237   3                                      delay(lightLevel);
 238   3                                      ICN2012_E1 = 0; 
 239   3                                      delay(0xFF-lightLevel);         
 240   3                                      P0 += 0x20;     
C51 COMPILER V9.57.0.0   DISPLAY                                                           03/25/2018 22:06:55 PAGE 5   

 241   3                              }
 242   2                      break;
 243   2              }
 244   1      }
 245          
 246          
 247          uint32_t dataCombine_T(uint8_t colLine)
 248          {
 249   1              uint16_t i,number;
 250   1              uint32_t result=0;
 251   1              if(Temperature<0)
 252   1              {
 253   2                      result = (result|nAsciiDot[0x60+colLine])<<4;   
 254   2                      Temperature = -Temperature;
 255   2              }
 256   1              number = Temperature/100;
 257   1              i = number*8+colLine;
 258   1              result = (result|nAsciiDot[i])<<5;
 259   1              number = (Temperature/10)%10;
 260   1              i = number*8+colLine;
 261   1              result = (result|nAsciiDot[i])<<5;
 262   1              result = (result|nAsciiDot[0x68+colLine])<<1;
 263   1              number = Temperature%10;
 264   1              i = number*8+colLine;
 265   1              result = (result|nAsciiDot[i]);
 266   1              result = (result|nAsciiDot[0x70+colLine]);
 267   1              return result;
 268   1      }
 269          
 270          uint32_t dataCombine_RH(uint8_t colLine)
 271          {
 272   1              uint16_t i,number;
 273   1              uint32_t result=0;
 274   1              number = RelativeHumidity/10;
 275   1              i = number*8+colLine;
 276   1              result = (result|nAsciiDot[i])<<5;
 277   1              number = RelativeHumidity%10;
 278   1              i = number*8+colLine;
 279   1              result = (result|nAsciiDot[i])<<6;
 280   1              result = (result|nAsciiDot[0x78+colLine]);
 281   1              return result;
 282   1      }
 283          
 284          void display_T_RH(void)
 285          {
 286   1              uint8_t i,j;
 287   1              uint32_t rowData;
 288   1              for(j=0;j<0xCF;j++)
 289   1              {       
 290   2                      lightLevel = j+0x20;
 291   2                      for(i=0;i<8;i++)
 292   2                      {
 293   3                              rowData = dataCombine_T(i);
 294   3                              write_ROW(rowData);
 295   3                              ICN2012_E1 = 1; 
 296   3                              delay(lightLevel);
 297   3                              ICN2012_E1 = 0; 
 298   3                              delay(0xFF-lightLevel);         
 299   3                              P0 += 0x20;     
 300   3                      }                       
 301   2              }
 302   1              for(j=0;j<0xCF;j++)
C51 COMPILER V9.57.0.0   DISPLAY                                                           03/25/2018 22:06:55 PAGE 6   

 303   1              {               
 304   2                      lightLevel = j+0x20;
 305   2                      for(i=0;i<8;i++)
 306   2                      {
 307   3                              rowData = dataCombine_RH(i);
 308   3                              write_ROW(rowData);
 309   3                              ICN2012_E1 = 1; 
 310   3                              delay(lightLevel);
 311   3                              ICN2012_E1 = 0; 
 312   3                              delay(0xFF-lightLevel);         
 313   3                              P0 += 0x20;     
 314   3                      }               
 315   2              }
 316   1              workMode = TimeMode;
 317   1      }
 318          
 319          uint32_t dataCombine_Date(uint8_t colLine)
 320          {
 321   1              uint16_t i,number;
 322   1              uint32_t result=0;
 323   1              number = time[4]>>4;
 324   1              i = number*8+colLine;
 325   1              result = (result|nAsciiDot[i])<<5;
 326   1              number = time[4]&0x0F;
 327   1              i = number*8+colLine;
 328   1              result = (result|nAsciiDot[i])<<5;
 329   1              result = (result|nAsciiDot[0x60+colLine])<<3;
 330   1              number = time[3]>>4;
 331   1              i = number*8+colLine;
 332   1              result = (result|nAsciiDot[i])<<5;
 333   1              number = time[3]&0x0F;
 334   1              i = number*8+colLine;
 335   1              result = (result|nAsciiDot[i])>>3;
 336   1              return result;
 337   1      }
 338          
 339          void display_Date(void)
 340          {
 341   1              uint8_t i;
 342   1              uint32_t rowData;
 343   1              for(timeCnt=0;timeCnt<3;)
 344   1              {
 345   2                      for(i=0;i<8;i++)
 346   2                      {
 347   3                              rowData = dataCombine_Date(i);
 348   3                              write_ROW(rowData);
 349   3                              ICN2012_E1 = 1; 
 350   3                              delay(lightLevel);
 351   3                              ICN2012_E1 = 0; 
 352   3                              delay(0xFF-lightLevel);         
 353   3                              P0 += 0x20;     
 354   3                      }
 355   2              }
 356   1              workMode = TimeMode;    
 357   1      }
 358          
 359          uint32_t dataCombine_Time(uint8_t colLine)
 360          {
 361   1              uint16_t i,number;
 362   1              uint32_t result=0;
 363   1              number = time[2]>>4;
 364   1              i = number*8+colLine;
C51 COMPILER V9.57.0.0   DISPLAY                                                           03/25/2018 22:06:55 PAGE 7   

 365   1              result = (result|nAsciiDot[i])<<5;
 366   1              number = time[2]&0x0F;
 367   1              i = number*8+colLine;
 368   1              result = (result|nAsciiDot[i])<<8;
 369   1              number = time[1]>>4;
 370   1              i = number*8+colLine;
 371   1              result = (result|nAsciiDot[i])<<5;
 372   1              number = time[1]&0x0F;
 373   1              i = number*8+colLine;
 374   1              result = (result|nAsciiDot[i])>>3;      
 375   1              if(time_sFlag)
 376   1                      result = result|((uint16_t)nAsciiDot[0x50+colLine]<<5);
 377   1              else
 378   1                      result = result|((uint16_t)nAsciiDot[0x58+colLine]<<5);
 379   1              return result;
 380   1      }
 381          
 382          void display_Time(void)
 383          {
 384   1              uint8_t i;
 385   1              uint32_t rowData;
 386   1              for(i=0;i<8;i++)
 387   1              {
 388   2                      rowData = dataCombine_Time(i);
 389   2                      write_ROW(rowData);
 390   2                      ICN2012_E1 = 1; 
 391   2                      delay(lightLevel);
 392   2                      ICN2012_E1 = 0; 
 393   2                      delay(0xFF-lightLevel);         
 394   2                      P0 += 0x20;     
 395   2              }       
 396   1      }
 397          
 398          static uint32_t display_DataHandle(uint32_t rowData)
 399          {
 400   1          uint8_t i,temp;
 401   1          uint32_t value=0;
 402   1              temp = (rowData>>16)&0xFF;
 403   1          for (i = 0; i < 8; ++i)
 404   1          {
 405   2              value <<= 1;
 406   2              value |= (temp&0x01);
 407   2              temp >>= 1; 
 408   2          }   
 409   1              temp = (rowData>>8)&0xFF;
 410   1          for (i = 0; i < 8; ++i)
 411   1          {
 412   2              value <<= 1;
 413   2              value |= (temp&0x01);
 414   2              temp >>= 1; 
 415   2          }
 416   1              temp = rowData&0xFF;
 417   1          for (i = 0; i < 8; ++i)
 418   1          {
 419   2              value <<= 1;
 420   2              value |= (temp&0x01);
 421   2              temp >>= 1; 
 422   2          }
 423   1          return ~value;
 424   1      }
 425          
 426          void write_ROW(uint32_t rowData)
C51 COMPILER V9.57.0.0   DISPLAY                                                           03/25/2018 22:06:55 PAGE 8   

 427          {
 428   1              uint8_t i;
 429   1      
 430   1              HC595_RCLK = 0;
 431   1              rowData = display_DataHandle(rowData);
 432   1              
 433   1              for(i=0;i<24;i++)
 434   1              {
 435   2                      HC595_SCLK = 0;
 436   2                      if(rowData&0x800000)
 437   2                      {
 438   3                              HC595_SER=1;
 439   3                      }
 440   2                      else
 441   2                      {
 442   3                              HC595_SER=0;
 443   3                      }
 444   2                      HC595_SCLK = 1;
 445   2                      rowData <<= 1;          
 446   2              }
 447   1              HC595_RCLK = 1;
 448   1      }
 449          
 450          void display(uint8_t mode)
 451          {
 452   1              uint8_t i;
 453   1              uint32_t rowData;
 454   1              for(i=0;i<8;i++)
 455   1              {
 456   2                      rowData = dataCombine_Time(i);                          
 457   2                      write_ROW(rowData);
 458   2                      ICN2012_E1 = 1; 
 459   2                      delay(lightLevel);
 460   2                      ICN2012_E1 = 0; 
 461   2                      delay(0xFF-lightLevel);         
 462   2                      P0 += 0x20;                                     
 463   2              }
 464   1      }
*** WARNING C280 IN LINE 450 OF USER\display.c: 'mode': unreferenced local variable
 465          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2938    ----
   CONSTANT SIZE    =    152    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      69
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
